import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { format, startOfWeek, addDays, startOfMonth, endOfMonth, isSameMonth, addWeeks, subWeeks } from 'date-fns';
import { fr } from 'date-fns/locale';
import { Recipe, ChildProfile } from '../types';
import { ChevronLeft, ChevronRight, Clock, Utensils, Trash2, Sparkles, RotateCcw } from 'lucide-react';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { Badge } from '@/components/ui/badge';

interface WeeklyCalendarProps {
  selectedDate: Date;
  onSelectDate: (date: Date) => void;
  plannedRecipes: { [key: string]: { [childId: string]: Recipe } };
  viewMode: 'week' | 'month';
  selectedChildren: ChildProfile[];
  readOnly?: boolean;
  onRemoveRecipe?: (date: string, childId: string) => void;
  isAutoGenerated?: boolean;
}

export const WeeklyCalendar = ({ 
  selectedDate, 
  onSelectDate, 
  plannedRecipes, 
  viewMode,
  selectedChildren,
  readOnly = false,
  onRemoveRecipe,
  isAutoGenerated = false
}: WeeklyCalendarProps) => {
  const getDaysToDisplay = () => {
    if (viewMode === 'week') {
      const startOfCurrentWeek = startOfWeek(selectedDate, { weekStartsOn: 1 });
      return Array.from({ length: 7 }, (_, i) => addDays(startOfCurrentWeek, i));
    } else {
      const start = startOfMonth(selectedDate);
      const end = endOfMonth(selectedDate);
      const startWeek = startOfWeek(start, { weekStartsOn: 1 });
      const days = [];
      let day = startWeek;
      
      while (day <= end || days.length % 7 !== 0) {
        days.push(day);
        day = addDays(day, 1);
      }
      
      return days;
    }
  };

  const handlePreviousWeek = () => {
    onSelectDate(subWeeks(selectedDate, 1));
  };

  const handleNextWeek = () => {
    onSelectDate(addWeeks(selectedDate, 1));
  };

  const getInitials = (name: string) => {
    return name.substring(0, 2).toUpperCase();
  };

  // Déterminer si une recette est une réutilisation dans la semaine
  const isRecipeReuse = (recipeId: string, currentDate: string): boolean => {
    const current = new Date(currentDate);
    
    // Chercher si cette recette est utilisée un jour antérieur dans la semaine
    for (const [dateStr, childRecipes] of Object.entries(plannedRecipes)) {
      const date = new Date(dateStr);
      if (date < current) {
        for (const recipe of Object.values(childRecipes)) {
          if (recipe.id === recipeId) {
            return true;
          }
        }
      }
    }
    return false;
  };

  // Compter les utilisations d'une recette dans la semaine
  const getRecipeUsageCount = (recipeId: string): number => {
    let count = 0;
    for (const childRecipes of Object.values(plannedRecipes)) {
      for (const recipe of Object.values(childRecipes)) {
        if (recipe.id === recipeId) {
          count++;
        }
      }
    }
    return count;
  };

  const days = getDaysToDisplay();
  const gridCols = viewMode === 'week' ? 'grid-cols-1' : 'md:grid-cols-7';
  const startDate = days[0];
  const endDate = days[days.length - 1];

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between bg-background p-4 rounded-lg shadow-sm">
        <Button
          variant="outline"
          size="sm"
          onClick={handlePreviousWeek}
          className="flex items-center gap-2"
        >
          <ChevronLeft className="h-4 w-4" />
          Semaine précédente
        </Button>
        
        <div className="text-center">
          <h3 className="text-lg font-semibold">
            {format(startDate, 'd MMMM', { locale: fr })} - {format(endDate, 'd MMMM yyyy', { locale: fr })}
          </h3>
          {isAutoGenerated && (
            <span className="text-sm text-muted-foreground">
              Planning généré automatiquement
            </span>
          )}
        </div>

        <Button
          variant="outline"
          size="sm"
          onClick={handleNextWeek}
          className="flex items-center gap-2"
        >
          Semaine suivante
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>

      <div className={`grid ${gridCols} gap-4`}>
        {days.map((day) => {
          const formattedDate = format(day, 'yyyy-MM-dd');
          const dayRecipes = plannedRecipes[formattedDate] || {};
          const isCurrentMonth = isSameMonth(day, selectedDate);
          
          return (
            <Card 
              key={day.toString()}
              className={`p-4 ${!readOnly ? 'hover:bg-secondary/10 transition-colors' : ''} ${
                format(day, 'yyyy-MM-dd') === format(selectedDate, 'yyyy-MM-dd')
                  ? 'border-primary/50'
                  : ''
              } ${
                !isCurrentMonth && viewMode === 'month' ? 'opacity-50' : ''
              }`}
              onClick={() => !readOnly && onSelectDate(day)}
            >
              <div className="text-center mb-4 pb-2 border-b">
                <div className="font-medium text-lg text-primary">
                  {format(day, 'EEEE', { locale: fr })}
                </div>
                <div className="text-sm text-muted-foreground">
                  {format(day, 'd MMMM', { locale: fr })}
                </div>
              </div>
              
              {Object.keys(dayRecipes).length > 0 && (
                <div className="space-y-3">
                  {Object.entries(dayRecipes).map(([childId, recipe]) => {
                    const child = selectedChildren.find(c => c.id === childId);
                    if (!child) return null;

                    const isReuse = isRecipeReuse(recipe.id, formattedDate);
                    const usageCount = getRecipeUsageCount(recipe.id);

                    return (
                      <div key={`${childId}-${recipe.id}`} className="p-3 bg-secondary/20 rounded-lg">
                        <div className="flex items-start justify-between gap-2">
                          <div className="flex-1">
                            {/* Badge réutilisation ou nouvelle recette */}
                            {isReuse ? (
                              <Badge variant="outline" className="text-[10px] px-1.5 py-0 mb-1.5 bg-emerald-50 text-emerald-700 border-emerald-200 dark:bg-emerald-950/30 dark:text-emerald-400 dark:border-emerald-800">
                                <RotateCcw className="w-2.5 h-2.5 mr-0.5" />
                                Déjà préparé
                              </Badge>
                            ) : (
                              <Badge variant="outline" className="text-[10px] px-1.5 py-0 mb-1.5 bg-violet-50 text-violet-700 border-violet-200 dark:bg-violet-950/30 dark:text-violet-400 dark:border-violet-800">
                                <Sparkles className="w-2.5 h-2.5 mr-0.5" />
                                Nouvelle recette
                              </Badge>
                            )}
                            
                            <div className="flex items-center gap-2">
                              <Tooltip>
                                <TooltipTrigger>
                                  <Avatar className="h-6 w-6">
                                    <AvatarFallback className="text-xs">
                                      {getInitials(child.name)}
                                    </AvatarFallback>
                                  </Avatar>
                                </TooltipTrigger>
                                <TooltipContent>
                                  <p>{child.name}</p>
                                </TooltipContent>
                              </Tooltip>
                              <h4 className="font-medium line-clamp-2">{recipe.name}</h4>
                            </div>
                            <div className="flex items-center gap-2 mt-1 text-sm text-muted-foreground">
                              <div className="flex items-center gap-1">
                                <Clock className="w-3 h-3" />
                                <span>{recipe.preparation_time} min</span>
                              </div>
                              <div className="flex items-center gap-1">
                                <Utensils className="w-3 h-3" />
                                <span>{recipe.meal_type}</span>
                              </div>
                              {usageCount > 1 && (
                                <span className="text-xs text-emerald-600 dark:text-emerald-400">
                                  ×{usageCount} cette semaine
                                </span>
                              )}
                            </div>
                          </div>

                          {!readOnly && onRemoveRecipe && (
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Button
                                  variant="ghost"
                                  size="icon"
                                  className="h-6 w-6 text-destructive hover:text-destructive hover:bg-destructive/10"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    onRemoveRecipe(formattedDate, childId);
                                  }}
                                >
                                  <Trash2 className="h-4 w-4" />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p>Supprimer la recette pour {child.name}</p>
                              </TooltipContent>
                            </Tooltip>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </Card>
          );
        })}
      </div>
    </div>
  );
};